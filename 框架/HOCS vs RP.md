### HOCS VS Render Props

#### HOCS

- 支持ES6
- 复用性强，HOC是纯函数且返回值仍为组件，在使用时可以多层嵌套，在不同情境下使用特定的HOC组合也方便调试。
- 同样由于HOC是纯函数，支持传入多个参数，增强了其适用范围

但是：

- 当有多个HOC一同使用时，无法直接判断子组件的props是哪个HOC负责传递的。
- 重复命名的问题：若父子组件有同样名称的props，或使用的多个HOC中存在相同名称的props，则存在覆盖问题，而且react并不会报错。当然可以通过规范命名空间的方式避免。
- 在react开发者工具中观察HOC返回的结构，可以发现HOC产生了许多无用的组件，加深了组件层级。
- 同时，HOC使用了静态的合成，不能改变的，从`compose(cmp)`的时候已经决定了本身的合成。但是如果使用`Render Props`的话，各种组件被允许通过`state`这个参数获取数据，拿到属性即可动态在`Render Props`里面构成想要的合成渲染结构。


> 最后一点我本身对合成不大理解，读了官方文档之后，在这里作一下解释。合成即`composition`，在`React`的组件化开发写法中，使用组件的时候通常会在另一个组件内的`render`方法渲染而出，这叫`composition`。`React`提倡动态`composition`，即可配置地在`render`方法内渲染各个写好的组件，然而高阶组件的封装方式虽然复用了很多逻辑，但是因为多了一层组件，也失去了动态`composition`的优点。




#### Render Props

> 据说所有的HOCS都可以写成Render Props

- 支持ES6，和HOC一样
- 不用担心prop的命名问题，在render函数中只取需要的state
- 相较于HOC，不会产生无用的空组件加深层级
- 最重要的是，这里的构建模型是动态的，所有改变都在render中触发，能更好的利用react的生命周期。



---

但是不可否认的是，我认为HOCS仍然有值得使用的价值，包括本身就可以通过传入参数静态定制一些特性。

这里讨论的只是一种封装的模式，实际情况需要实际分析。