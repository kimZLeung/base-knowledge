## HTTP

---

## URI URL URN

- URL：URL属于URI，不但可以标识Web资源的位置，还指定了具体的操作和获取方式。同时指出了主要访问机制和网络位置
- URN：URN也属于URI，用特定命名空间的名字标识资源，使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。

for example

```
// URI 一个标识
http://test.io/posts/hello.html#intro

// URL 一个位置标识
http://test.io/posts/hello.html

// URN 一个名称标识
test.io/posts/hello.html#intro
```

- 初始版本的HTTP协议每进行一次HTTP通信就需要断开一次TCP连接，但是随着时代变迁，HTTP需要传输的东西多了起来，比如我们现在访问一个页面，需要发送的HTTP请求是几十级别的，因此要进行几十次级别的TCP三次握手和四次挥手，这将造成很多无谓的通信开销，所以HTTP/1.1和部分的HTTP/1.0实现了持久连接，就是HTTP一次传输完毕之后，只要没有说明确要断开，则会继续保持TCP连接。并且长连接让HTTP的管线化成为可能。管线化就是并行请求，不必等一个请求结束再开始另一个。

> 在HTTP/1.1中，所有连接都默认为持久连接，我们可以看到所有请求的请求头和响应头都带有`Connection`字段，默认为`keep-alive`，就是默认保持持久连接。当我们显式将其置为`close`的时候，将会关闭持久连接的方式。

- HTTP协议会通过编码把实体压缩，并在网络上传输，这样可以提高传输速率。提高传输速率的另一种方式就是，在面对比较大的实体时，HTTP会选择采用编码分割发送的方式，将实体分割成一个个块，又服务端接受并且解码，让服务端可以逐步展示页面。
- HTTP协议可以进行范围请求，服务端发的HTTP请求的头部带有一个字段`Range`来规定请求的范围。比如`Range: bytes=5001-`，服务端返回的响应的HTTP请求使用`Content-Range`来指定返回的范围，范围请求成功的状态码是206 Partial Content，若范围请求不成功。则会返回200 OK并且整个文件返回。
- HTTP协议还会进行内容协商返回。通过`Accept`，`Accept-Charset`，`Accept-Encoding`，`Accept-Language`，`Content-Language`这些包含在请求头部的字段，让服务端鉴别返回适合的内容（比如某网站的英文版或者中文版）。内容协商还分为三种类型
	- 服务器驱动，通过以上几个请求头鉴别返回内容
	- 客户端驱动协商，在页面上显示选项让用户选择
	- 透明协商，结合以上两种方法

---

## HTTP状态码

状态码通常会包含在响应报文的第一行，状态码是对返回的请求结果的一个简单描述。

粗略总结状态码类型：

- 1XX：信息性状态码，接受的请求正在处理
- 2XX：成功状态码，请求正常处理完毕
- 3XX：重定向状态码，需要进行附加操作以完成请求
- 4XX：客户端错误状态码，服务器无法处理请求
- 5XX：服务器错误状态码，服务器处理请求出错

具体到个别常用的状态码。

### 1XX 

- 100 Continue：客户端应继续发送请求。

```
ReqHeader
{
    Expect: 100-continue
}

Res
HTTP/1.1 100 continue
```

- 101 Switching Protocols：需要切换协议，服务器通过的`Upgrade`响应头字段通知客户端。 HTML5引入的`WebSocket`便是这样工作的。首先客户端请求websocket所在的URL，服务器返回101，然后便建立了全双工的TCP连接。 注意`Upgrade`和`Connection`头字段属于`Hop-by-hop`字段，设置Websocket代理时需要继续设置这两个字段，而不是简单地转发请求。

### 2XX 成功

- 200 OK：最常见的状态码，表示请求被正常地成功处理了。但是在响应的报文中，会因为请求方法不同而不同，因为我们都知道用`GET`和`HEAD`方法获取的东西不同，`GET`会获取到实体主体。而`HEAD`方法只会让响应返回头部，并不会返回实体主体。
- 204 No Content：表示请求已被成功处理，但是返回的响应报文中不包含实体的主体部分。也就是没有内容。一般用在客户端向服务端发送信息，但是服务端不需要发送新信息的情况。
- 206 Partial Content：表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。

### 3XX 重定向

> 为何要重定向：网页换域名了或者扩展名改变或者网站的目录调整，但是原来收藏了网页的用户点击收藏的目录访问的地址还是原来的那个，这个时候就需要重定向帮用户定向到新地址

- 301 Moved Permanently：永久性重定向，表示请求的资源已被分配了新的URI，会自动重定向到新的URI，新的URI将会作为响应头的`Location`字段返回。并且如果用户此前将这个页面收藏为了书签，则301会帮助用户更新书签。
- 302 Found：临时性重定向，表示请求的资源已被分配了新的URI，希望本次能使用新的URI访问。与301不同的是，因为302表示的是临时性质，所以并不会去更新用户的书签。

> 302可能会导致网址劫持。网址劫持：大部分的搜索引擎在大部分情况下，当收到302重定向时，一般只要去抓取目标网址就可以了。也就是说搜索结果显示的网页内容是重定向后的内容，但是网址显示的是重定向前的网址。

- 303 See Other：该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。
- 304 Not Modified：服务端资源未改变，可直接使用客户端未过期的缓存。304和重定向没关系。
- 307 Temporary Redirect：临时重定向，和302有相同的含义。不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。

### 4XX 客户端错误

- 400 Bad Request：表示请求报文中存在语法错误，服务器无法理解这一次的请求。（有可能是参数错误之类的）当错误发生时，需修改请求的内容后再次发送请求。
- 401 Unauthorized：未授权，该状态码表示发送的请求**需要通过认证**。服务端会返回401并且在首部带有一个`WWW-Authenticate`的字段用以指明服务器需要哪种方式的认证。当客户端再次请求该资源的时候，需要在请求头中的`Authorization`包含认证信息。另外，若服务器第二次请求本URI仍然返回401，则表示用户认证失败。
- 403 Forbidden：该状态码表示了对请求资源的访问**被服务器拒绝**了。未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。
- 404 Not Found：表明服务器上无法找到请求的资源，也可以使用在拒绝请求的时候。
- 405 Method Not Allowed：服务器禁止了使用当前 HTTP 方法的请求

### 5XX 服务器错误

- 500 Internal Server Error：该状态码表明服务器端在执行请求时发生错误。也有可能是Web应用存在的bug。
- 503 Service Unavailable：该状态码表明服务器暂时处于高负载或者正在进行停机维护，暂时无法处理请求。可以通过返回的首部的`Retry-After`字段告诉客户端什么时候好。

> 因为部分功能性状态码需要由服务器维护人员显式根据需求设定，没有设定的话则又HTTP默认会变为200 OK或者404 Not Found或者500 Internal Server Error，这都是HTTP通过一些内置的判断生成的默认值。所以有时候，返回的状态码和响应时错误的，比如有时候服务器内部发生错误，但是状态码依旧返回200 OK。因为状态码有时候会通过HTTP默认设置，但是真实情况并不是这样子的，而在服务器那边并没有显示设定状态码导致了这种情况。



## HTTP常见头部

**请求头：**

- Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）
- Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
- Content-Type：客户端发送出去实体内容的类型
- Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
- If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
- Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
- Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
- If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
- Cookie：有cookie并且同域访问时会自动带上
- Connection：当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
- Host：请求的服务器URL
- Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
- Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
- User-Agent：用户客户端的一些必要信息，如UA头部等

**响应头**：

- Access-Control-Allow-Headers: 服务器端允许的请求Headers
- Access-Control-Allow-Methods: 服务器端允许的请求方法
- Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
- Content-Type：服务端返回的实体内容的类型
- Date：数据从服务器发送的时间
- Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
- Last-Modified：请求资源的最后修改时间
- Expires：应该在什么时候认为文档已经过期,从而不再缓存它
- Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
- ETag：请求变量的实体标签的当前值
- Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
- Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
- Server：服务器的一些相关信息



## HTTP请求方法

- GET：获取资源
- POST：传输实体主体
- OPTIONS：询问支持的方法
- HEAD：获取报文首部
- PUT：传输文件，一般用来更新资源，但是不带验证机制
- DELETE：删除文件，但是不带验证机制
- TRACE：追踪路径
- CONNECT：要求用隧道协议链接代理



## HTTP协作的Web服务器

HTTP通信过程中除了客户端和服务端还可以存在

- 代理服务器
- 网关
- 隧道

> 代理服务器主要可以实现资源缓存（主要是响应返回时进行静态资源的缓存，缓存在代理的服务器中，但是会有缓存的时限，通过HTTP的一些头部协作），也可以实现一些类似访问限制之类的需求

> 网关能够使给服务器提供非HTTP协议服务，还可以提高通信的安全性，因为通过网关可以对通信线路进行加密

> 隧道可以确保客户端和服务端进行安全的（远距离的）通信

---

## HTTP的头部

具体可分为：

- 通用的头部字段：请求响应都可以使用的头部字段
- 请求用的头部字段：从客户端发送的请求会用到的头部字段，补充请求的附加内容，客户端信息之类的信息
- 响应的头部字段：从服务端返回的响应会用到的头部字段，补充响应的附加内容
- 实体头部字段：针对请求和响应报文的实体部分使用的头部，补充资源内容更新时间和实体有关的信息。

也可根据缓存代理和非缓存代理的行为分为2种类型

- 端到端头部：这一类头部会转发给最终接受目标，且会保存在由缓存生成的响应中
- 逐跳头部：这类头部只会对单次转发有效，会因为缓存或代理不再转发。具体头部如下
	- Connection
	- Keep-Alive
	- Proxy-Authenticate
	- Proxy-Authorization
	- Trailer
	- TE
	- Transfer-Encoding
	- Upgrade

---

## 认识HTTPS

> HTTP有很多不安全的地方，比如：传输过程中可能被认为窃听，通信的双方不能确认彼此真实身份，传输的报文的完整性不能得到保证。

所以 HTTPS = HTTP + 加密（握手建立连接后进行对称密码的加密传输） + 认证（CA证书） + 完整性保护（数字签名）

> 听起来好像牛逼了许多，但是HTTPS就是HTTP在通信接口部分用SSL和TLS协议代替了。HTTPS的通信变成了，HTTP先和SSL通信，然后SSL再和TCP通信，多一层SSL从而进行对HTTP通信的保护。


- 共享秘钥：把秘钥通过HTTP传输到对方，再让对方使用秘钥解密报文，但是把秘钥也发送出去这个过程也会有点点危险，可能会被盗取
- 公开密钥：使用一对秘钥。接收方把自己的公钥发给发送方，发送方用对方的公钥进行加密，发过去后由对方的私钥解密，但是这样做开销较大，速度较慢

HTTPS结合了这两种加密方式，进行混合加密：使用公开密钥的方式把共享的密钥通过安全的方式发给对方，然后通过共享秘钥进行消息的传输。

> 通常来说，服务端给客户端发送的第一次的公开密钥未必是**真正**的公开密钥，所以我们需要借助第三方的认证机构，为服务端生成公开密钥证书，然后服务端发送公开密钥证书过来客户端，客户端通过提前植入浏览器的私钥认证证书的有效性（认证），从而确认公开密钥的安全性，然后通过公开密钥加密共享秘钥，传送过去服务端，服务端通过自己的私钥解密，从而使双方都获取安全的共享秘钥（加密），然后就可以通过安全的共享秘钥进行信息传输。同时应用层会附加一种MAC的报文摘要，以确认报文的完整性（完整性保护）



**关于数字签名的完整性保护**：通过发送方对原文进行hash运算产生一个摘要信息，然后通过发送方的私钥进行加密，从而产生数字签名。接收方需要对接受的原文进行hash运算产生出一个摘要信息，再用发送方的公钥对数字签名进行解密，对比得出信息是否被篡改。

**但是**：如果只有数字签名，并不一定能保证发送方的可靠性，因为接收方不能确定所使用解密的公钥就是真正的发送方的公钥。所以需要数字证书，数字证书是一个权威的值得信赖的第三方机构(一般是由政府审核并授权的机构)来统一对外发放主机机构的公钥。

有了这个正确的发送方真实性保证，便可以通过数字签名准确地鉴别信息完整性了。



### HTTP和HTTPS的区别

- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用
- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全
- 传输效率上 HTTP 要高于 HTTPS ，因为 HTTPS 需要经过加密过程，过程相比于 HTTP 要繁琐一点，效率上低一些也很正常



### HTTPS握手过程

- **客户端发出请求（ClientHello）** 
  - 支持的协议版本
  - 支持的加密方法
  - 第一个随机数
- **服务器回应（SeverHello）**
  - 确认使用的加密通信协议版本
  - 确认使用的加密方法
  - 第二个随机数
  - 服务器证书
- **客户端回应** ：先验证证书，如果证书不通过验证，则向用户发出一个警告。如果没有问题，就从证书中取出服务器公钥
  - 第三个随机数（pre-master key），经过服务器公钥加密。（**RSA算法加密**）
  - 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
  - 客户端握手结束通知
- **服务器的最后回应**
  - 编码改变通知
  - 服务器握手结束通知
- **开始通信**，通过三个随机数生成的对称秘钥通过AES算法进行加密数据传输





**HTTPS的缺点**：由于要进行SSL通信，加密解密等操作，HTTPS与纯文本通信相比消耗更多的CPU和内存，简单来说就是开销会变大。因此，如果是非敏感信息则进行HTTP通信，只有在包含个人信息等敏感通信时才进行HTTPS通信

HTTPS的缺点的优化：由于HTTPS的主要性能消耗在于建立一个新的SSL连接的一个建立协商对称秘钥的过程（因为这其中使用了非对称密码体制交换信息，所以开销比较大）。有两种方法可以恢复原来的session，复用原来建立好的连接，不用重新握手生成秘钥

- Session ID：每一次对话都有一个编号（Session ID）。如果对话中断，下次重连的时候，只要客户端给出这个编号，且服务器有这个编号的记录，双方就可以重新使用已有的”对话密钥”，而不必重新生成一把。这个方法适用于所有浏览器，但是如果客户端的请求发到另一台服务器，就无法恢复对话（往往在负载均衡的做法下难以发挥优势）
- Session Ticket：客户端发送一个服务器在上一次对话中发送过来的Session Ticket。这个Session Ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到Session Ticket以后，解密后就不必重新生成对话密钥了。不过目前只有Firefox和Chrome支持这个方法，但是不同服务端也可快速建立握手。**值得注意的是，为了让一台服务器生成的 Session Ticket 能被另外服务器承认，往往需要对 Web Server 进行额外配置。**

---






