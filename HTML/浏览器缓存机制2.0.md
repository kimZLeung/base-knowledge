# 浏览器缓存机制

---

我们每一次使用浏览器去访问页面都会经过多个HTTP请求，当然，有相当一大部分的请求返回的是静态资源（如JS，CSS，IMG）这类的不经常修改变化的文件。而这一类文件通常来说也是比较大的，如果我们将这些文件缓存下来的话，将会加快页面的加载速度，省下每次的请求时间，从而达到优化页面的目的。

---

## 强缓存和协商缓存

强缓存：状态码（200 from cache）客户端直接从缓存中请求，若缓存的数据还未过期，则直接从缓存中取出使用，若已过期，则进入协商缓存阶段。（现在有分为from memory cache 还是 from disk cache）顾名思义就是在内存中的缓存和在磁盘中的缓存。

协商缓存：状态码（304 not modify）强缓存没有命中，则客户端会向服务器发送一个关于缓存文件的标识，服务器验证这个标识来判断静态资源缓存是否失效，若没失效则直接通知客户端可以从缓存中取出，若失效了则把最新的文件返回给客户端。

---

## 强缓存的详细过程

客户端有一套自己的方法来验证强缓存的静态文件是否失效。

- HTTP 1.0 时代：Expires

> Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过存在一个问题，到期时间是服务端生成的，而请求时间是客户端生成的，并不能保证服务端和客户端的实际时间没有太大误差，这会导致缓存命中的误差。所以我们现在使用Cache-Control

- HTTP 1.1 时代：Cache-Control

> 鉴于以上Expires的缺点，我们HTTP1.1使用Cache-Control代替它，Cache-Control常见的取值有private、public、no-cache、max-age，no-store，默认为private。（这里讨论响应头，Cache-Control可以存在在响应头和请求头中，但一般来说会在响应头中并且制定该资源缓存机制，在请求头中发挥的作用不大）

- private：仅向特定用户返回响应（只在响应头中存在）
- public：可向任意方提供响应的缓存（只在响应头中存在）
- max-age=xxx：缓存内容将在xxx秒后消失
- no-cache：需要使用协商缓存来验证缓存数据
  - no-cache处于响应头上时，表示获取该资源前需要经过服务端验证（协商缓存）
  - 当处于请求头上时，则表示必须重新获取资源，协商缓存和强缓存都不会经过
- no-store：所有内容都不会缓存，强缓存和协商缓存都不触发

当服务端同时设置了Cache-Control和Expires的时候，就会根据Cache-Control作为判断标准

实际情况

> 当客户端第一次向服务端请求某个静态文件`xxx.js`的时候，服务器收到请求并且进行文件的返回，并且在响应头上带上一个`Cache-Control: max-age=600`，然后浏览器收到之后，默认为允许缓存，所以浏览器会把这份`xxx.js`缓存起来，十分钟以内再次请求的话，浏览器会直接从缓存中获取，放回响应的状态码是 200 from cache 。但是如果10分钟过去了，缓存的时限也过去了，所以会向服务端去请求，这个时候一般就轮到协商缓存出场了

---

## 协商缓存的详细过程

> 浏览器第一次请求静态资源时，服务器会将缓存标识和数据一起返回给客户端，客户端将两个都备份到缓存中。需要到协商缓存时，客户端会将已备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，若成功，则返回 304 not modify 状态码，通知客户端可以使用缓存。

- Last-Modified / If-Modified-Since

`Last-Modified`就是那个第一次请求静态资源时**服务端返回**的缓存标识，这个键的值是这个资源最后修改的时间。然后进行协商缓存的时候，由**客户端**发起的请求中，会带有`If-Modified-Since`这个请求头，当服务器发现这个请求头后，则会与被请求的资源的最后的修改时间作对比，若最后修改的时间大于这次请求发过来的`If-Modified-Since`，就表示静态资源作了修改，对比缓存失败，则会整个静态资源重新给客户端返回。若`If-Modified-Since`小于或者等于资源的最后修改时间，则表示资源无更新，直接返回304让浏览器使用之前缓存好的文件。


- Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）

`Etag`也是那个第一次请求静态资源时**服务端返回**的缓存标识，不过不同的是，`Etag`并不是根据时间计算的，它有多种计算方式。

> `Etag`可能会比`Last-Modified`更加精确，只要资源确切发生了变化，则`Etag`肯定会变化。`Last-Modified`并不会计算秒级内的修改。而只要资源变化了，`Etag`就会变化。

然后进行协商缓存的时候，**客户端**会在发起的请求中带上`If-None-Match`字段来携带这个`Etag`，让其发送到服务端中，然后服务端会用这个字段与对应资源的`Etag`进行比较。情况和上面的`Last-Modified / If-Modified-Since`很相似。

---

## 每一次说到缓存都会说到的浏览器刷新方法

- 选中浏览器地址，回车
- F5
- Ctrl + F5

选中浏览器地址，回车

> 这种方式是不会对原来的资源有任何影响，强缓存 -> 对比缓存 -> 请求资源

F5

> 这种方式把帮助强缓存系列的响应头的信息重置。使得强缓存失效，最多只能使用协商缓存。原理是每个请求带上`Cache-Control:max-age=0`

Ctrl + F5

> 这种方式会使强缓存和协商缓存同时失效，只能从服务器重新请求静态资源，给每个请求带上`Cache-Control:no-cache`

---

> 但是我自己在各个网站进行测试的时候，用F5刷新，各种网站还是会返回`200 from XX cache`的状态码，也就是使用了强缓存，令我十分费解。
