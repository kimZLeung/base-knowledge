### 浏览器渲染过程

#### 构建DOM树

- 编码： **先将HTML的原始字节数据转换为文件指定编码的字符。**
- 令牌化： 然后**浏览器会根据HTML规范来将字符串转换成各种令牌**（如`<html>`、`<body>`这样的标签以及标签中的字符串和属性等都会被转化为令牌，每个令牌具有特殊含义和一组规则）。令牌记录了标签的开始与结束，通过这个特性可以轻松判断一个标签是否为子标签（假设有`<html>`与`<body>`两个标签，当`<html>`标签的令牌还未遇到它的结束令牌`</html>`就遇见了`<body>`标签令牌，那么`<body>`就是`<html>`的子标签）。
- 生成对象： **接下来每个令牌都会被转换成定义其属性和规则的对象（这个对象就是节点对象）。**
- 构建完毕： **DOM树构建完成，整个对象集合就像是一棵树形结构**。

#### 构建CSSOM树

CSSOM树会比较着DOM树进行构建的，然后合并的时候拿到适当的节点合并到对应的DOM节点就行了。

#### 构建渲染树（Render Tree）

- 浏览器会先从`DOM`树的根节点开始遍历每个可见节点（不可见的节点自然就没必要渲染到页面了，不可见的节点还包括被`CSS`设置了`display: none`属性的节点，值得注意的是`visibility: hidden`属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，所以它会被渲染成一个空框）。
- 对每个可见节点，找到其适配的`CSS`样式规则并应用。
- 渲染树构建完成，每个节点都是可见节点并且都含有其内容和对应规则的样式。

#### 布局Layout

通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置

#### 绘制（Painting）

将每个节点绘制到屏幕



### 重排和重绘

- 重绘：屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。
- 重排：元件的几何尺寸变了，我们需要重新验证并计算Render Tree。

Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow

触发重排的因素：

- 增加、删除、修改DOM结点时，会导致Reflow或Repaint
- 移动DOM的位置。
- 修改CSS样式的时候。
- Resize窗口的时候（移动端没有这个问题），或是滚动的时候。
- 修改网页的默认字体时。
- CSS3 动画
- 获取偏移高度或偏移宽度



最佳实践：

1. 多个读写DOM操作放一起
2. 缓存已经得到的重排结果
3. 通过class改变样式
4. 使用离线DOM，而不直接操作真实的DOM书。比如可以用文档碎片 Document Fragment对象
5. 将要剧烈重排的元素先设成display：none，操作完再show出来
6. position为absolute和fixed的元素因为脱离了普通文档流，对DOM树的影响较小。



### 对于渲染过程的优化

1. HTML文档结构层次尽量少，最好不深于六层
2. JS脚本尽量后放
3. 少量首屏样式内联放在标签内
4. 样式结构层次尽量简单
5. 在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发回流
6. 减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画
7. 动画尽量使用在绝对定位或固定定位的元素上
8. 隐藏在屏幕外，或在页面滚动时，尽量停止动画
9. 尽量缓存DOM查找，查找器尽量简洁
10. 涉及多域名的网站，可以开启域名预解析，使用`<link rel='dns-prefetch' />`

